## **Effort Tracking**

### **Approach to Time Estimation**

I estimated my effort based on my experience with previous ICS assignments, particularly WODs and multi-file programming tasks. Instead of relying on exact hour counts, I judged effort by task complexity, familiarity with the technology, and how much debugging or integration I expected the task to require. Tasks involving new components, database logic, or authentication were estimated higher than simple UI or refactoring work.

I often intentionally overestimated my coding time to leave room for unexpected issues such as bugs, merge conflicts, or changes in requirements. From past experience, I knew that even straightforward tasks could expand once testing and edge cases were considered. This approach helped ensure I did not rush work near deadlines, even when the actual implementation took less time than expected.

### **Value of Pre-Planning Effort**

Even when my estimates were inaccurate, estimating in advance was still valuable. Pre-planning helped me organize my schedule and decide which tasks needed to be started earlier. Estimating also made me more aware of how AI-assisted development affected my workflow. While tools like GitHub Copilot sometimes accelerated coding, they also introduced additional time spent reviewing, debugging, and adapting generated code to fit project requirements. Pre-planning made it easier to anticipate these trade-offs and avoid underestimating the total effort.

### **Usefulness of Tracking Actual Effort**

Tracking actual effort helped me identify patterns in how I worked. I noticed that debugging and fixing integration issues often took significantly longer than writing new code. In contrast, tasks like basic component creation or small UI changes were usually completed faster than expected.

Even when my tracking was not perfectly precise, comparing estimates to actual effort helped improve my awareness of where time was really being spent. This information was useful for adjusting later estimates and deciding how much buffer time to include for complex tasks.

### **How I Recorded My Effort**

I tracked my effort more consistently by using timers and manual notes to record work sessions.

Coding effort included implementation, testing, debugging, and reviewing AI-generated code. Non-coding effort included planning, researching documentation, troubleshooting errors. While this method was not exact to the minute, I believe it provided a reasonably accurate and honest representation of the effort I contributed.

### **Lessons Learned for Better Estimation**

For future projects, I would improve my estimation and tracking process by:

* Using past tasks as reference points instead of guessing from scratch

* Breaking large issues into smaller, easier-to-estimate subtasks

* Explicitly accounting for debugging, testing, and AI code review time

* Using a more consistent tracking tool from the beginning of the project

These changes would make future estimates more realistic and improve the usefulness of effort tracking over time.

### **Conclusion: Reflections on Effort Estimation and Tracking**

Through this experience, I learned that effort estimation and tracking are valuable even when estimates are imperfect. Estimating effort ahead of time helped me manage my workload and avoid last-minute stress, while tracking actual effort helped me better understand how I work and where time is truly spent.

